```c
#define ext4_iget(sb, ino, flags) \
	__ext4_iget((sb), (ino), (flags), __func__, __LINE__)

struct ext4_iloc
{
	struct buffer_head *bh; // 在磁盘上的数据
	unsigned long offset; // 偏移
	ext4_group_t block_group; // 所在的组
};

struct inode *__ext4_iget(struct super_block *sb, unsigned long ino,
			  ext4_iget_flags flags, const char *function,
			  unsigned int line)
{
	struct ext4_iloc iloc;
	struct ext4_inode *raw_inode;
	struct ext4_inode_info *ei;
	struct inode *inode;
	journal_t *journal = EXT4_SB(sb)->s_journal;
	long ret;
	loff_t size;
	int block;
	uid_t i_uid;
	gid_t i_gid;
	projid_t i_projid;

	// 检查ino合法性
	/*
	 (不是特殊的 && 小于第1个ino && 不等于rootino) ||
	 ino 小于 rootino ||
	 ino 大于inode数量
	 */
	
	if ((!(flags & EXT4_IGET_SPECIAL) &&
	     (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)) ||
	    (ino < EXT4_ROOT_INO) ||
	    (ino > le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count))) {
		if (flags & EXT4_IGET_HANDLE)
			return ERR_PTR(-ESTALE);
		__ext4_error(sb, function, line, EFSCORRUPTED, 0,
			     "inode #%lu: comm %s: iget: illegal inode #",
			     ino, current->comm);
		return ERR_PTR(-EFSCORRUPTED);
	}

	// 获取inode, 先从内存里取,如果没有的话就新创建
	inode = iget_locked(sb, ino);
	if (!inode)
		return ERR_PTR(-ENOMEM);

	// 如果不是新创建的就直接返回
	if (!(inode->i_state & I_NEW))
		return inode;

	// 走到这儿说明是新创建的, 需要从磁盘上读取inode内容

	// 获取ext4的inode
	ei = EXT4_I(inode);
	iloc.bh = NULL;

	// 从磁盘上读取inode的信息
	ret = __ext4_get_inode_loc_noinmem(inode, &iloc);
	if (ret < 0)
		goto bad_inode;
	// 获取磁盘上的inode
	raw_inode = ext4_raw_inode(&iloc);

	// root的link为0, root是在创建文件系统的时候就创建好的, 所以link不能为0
	if ((ino == EXT4_ROOT_INO) && (raw_inode->i_links_count == 0)) {
		ext4_error_inode(inode, function, line, 0,
				 "iget: root inode unallocated");
		ret = -EFSCORRUPTED;
		goto bad_inode;
	}

	// ?
	if ((flags & EXT4_IGET_HANDLE) &&
	    (raw_inode->i_links_count == 0) && (raw_inode->i_mode == 0)) {
		ret = -ESTALE;
		goto bad_inode;
	}

	// 根据inode大小来判断是新的inode还是老的
	if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {
		// 新的inode支持额外空间

		// 设置额外空间
		ei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);

		// 判断是否合法, 空间是4字节对齐的
		if (EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >
			EXT4_INODE_SIZE(inode->i_sb) ||
		    (ei->i_extra_isize & 3)) {
			ext4_error_inode(inode, function, line, 0,
					 "iget: bad extra_isize %u "
					 "(inode size %u)",
					 ei->i_extra_isize,
					 EXT4_INODE_SIZE(inode->i_sb));
			ret = -EFSCORRUPTED;
			goto bad_inode;
		}
	} else
		ei->i_extra_isize = 0;

	// 如果有元数据校验, 则先计算种子
	if (ext4_has_metadata_csum(sb)) {
		struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);
		__u32 csum;
		__le32 inum = cpu_to_le32(inode->i_ino);
		__le32 gen = raw_inode->i_generation;
		// 计算ino的校验和
		csum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&inum,
				   sizeof(inum));
		// 根据年代的校验和生成种子
		ei->i_csum_seed = ext4_chksum(sbi, csum, (__u8 *)&gen,
					      sizeof(gen));
	}

	// 计算校验和
	if ((!ext4_inode_csum_verify(inode, raw_inode, ei) ||
	    ext4_simulate_fail(sb, EXT4_SIM_INODE_CRC)) &&
	     (!(EXT4_SB(sb)->s_mount_state & EXT4_FC_REPLAY))) {
		ext4_error_inode_err(inode, function, line, 0,
				EFSBADCRC, "iget: checksum invalid");
		ret = -EFSBADCRC;
		goto bad_inode;
	}

	// 下面是从磁盘上的inode给内存里的inode设置信息

	// mode
	inode->i_mode = le16_to_cpu(raw_inode->i_mode);

	// uid
	i_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);

	// gid
	i_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);

	// project是一种配额特性. todo: 后面看
	if (ext4_has_feature_project(sb) &&
	    EXT4_INODE_SIZE(sb) > EXT4_GOOD_OLD_INODE_SIZE &&
	    EXT4_FITS_IN_INODE(raw_inode, ei, i_projid))
		i_projid = (projid_t)le32_to_cpu(raw_inode->i_projid);
	else
		i_projid = EXT4_DEF_PROJID;

	// 有uid32
	if (!(test_opt(inode->i_sb, NO_UID32))) {
		i_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;
		i_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;
	}

	// 给inode设置uid, gid
	i_uid_write(inode, i_uid);
	i_gid_write(inode, i_gid);

	// 设置project id
	ei->i_projid = make_kprojid(&init_user_ns, i_projid);
	// 链接数
	set_nlink(inode, le16_to_cpu(raw_inode->i_links_count));

	// 清除i_state_flags
	ext4_clear_state_flags(ei);	/* Only relevant on 32-bit archs */
	ei->i_inline_off = 0;
	ei->i_dir_start_lookup = 0;

	// 删除dtime
	ei->i_dtime = le32_to_cpu(raw_inode->i_dtime);


	// nfs做的一些检查
	/* We now have enough fields to check if the inode was active or not.
	 * This is needed because nfsd might try to access dead inodes
	 * the test is that same one that e2fsck uses
	 * NeilBrown 1999oct15
	 */
	if (inode->i_nlink == 0) {
		if ((inode->i_mode == 0 ||
		     !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS)) &&
		    ino != EXT4_BOOT_LOADER_INO) {
			/* this inode is deleted */
			ret = -ESTALE;
			goto bad_inode;
		}
		/* The only unlinked inodes we let through here have
		 * valid i_mode and are being read by the orphan
		 * recovery code: that's fine, we're about to complete
		 * the process of deleting those.
		 * OR it is the EXT4_BOOT_LOADER_INO which is
		 * not initialized on a new filesystem. */
	}
	// 设置flag
	ei->i_flags = le32_to_cpu(raw_inode->i_flags);
	ext4_set_inode_flags(inode, true);

	// inode的块数
	inode->i_blocks = ext4_inode_blocks(raw_inode, ei);

	// acl值
	ei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl_lo);
	if (ext4_has_feature_64bit(sb))
		ei->i_file_acl |=
			((__u64)le16_to_cpu(raw_inode->i_file_acl_high)) << 32;
	// 文件大小
	inode->i_size = ext4_isize(sb, raw_inode);
	if ((size = i_size_read(inode)) < 0) {
		ext4_error_inode(inode, function, line, 0,
				 "iget: bad i_size value: %lld", size);
		ret = -EFSCORRUPTED;
		goto bad_inode;
	}
	// 没有dir_index特性,但是inode却有dir_index标志
	if (!ext4_has_feature_dir_index(sb) && ext4_has_metadata_csum(sb) &&
	    ext4_test_inode_flag(inode, EXT4_INODE_INDEX)) {
		ext4_error_inode(inode, function, line, 0,
			 "iget: Dir with htree data on filesystem without dir_index feature.");
		ret = -EFSCORRUPTED;
		goto bad_inode;
	}

	// 盘上大小
	ei->i_disksize = inode->i_size;

	// 配额
#ifdef CONFIG_QUOTA
	ei->i_reserved_quota = 0;
#endif
	// 年代
	inode->i_generation = le32_to_cpu(raw_inode->i_generation);
	// 所在组
	ei->i_block_group = iloc.block_group;

	// 上次分配的组设置为所有
	ei->i_last_alloc_group = ~0;
	// 在内存里的inode里保存的块号也是小端序的
	for (block = 0; block < EXT4_N_BLOCKS; block++)
		ei->i_data[block] = raw_inode->i_block[block];
	// 孤儿列表
	INIT_LIST_HEAD(&ei->i_orphan);
	// 初始化fast_commit相关字段
	ext4_fc_init_inode(&ei->vfs_inode);

	// 如果有事务, 则设置事务id
	if (journal) {
		transaction_t *transaction;
		tid_t tid;

		read_lock(&journal->j_state_lock);
		if (journal->j_running_transaction)
			transaction = journal->j_running_transaction;
		else
			transaction = journal->j_committing_transaction;
		if (transaction)
			tid = transaction->t_tid;
		else
			tid = journal->j_commit_sequence;
		read_unlock(&journal->j_state_lock);
		ei->i_sync_tid = tid;
		ei->i_datasync_tid = tid;
	}

	if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {
		if (ei->i_extra_isize == 0) {
			// 额外空间还没用
			BUILD_BUG_ON(sizeof(struct ext4_inode) & 3);
			ei->i_extra_isize = sizeof(struct ext4_inode) -
					    EXT4_GOOD_OLD_INODE_SIZE;
		} else {
			// 额外空间用了, 则获取相应数据(扩展属性) 
			ret = ext4_iget_extra_inode(inode, raw_inode, ei);
			if (ret)
				goto bad_inode;
		}
	}

	// 设置各种时间
	EXT4_INODE_GET_XTIME(i_ctime, inode, raw_inode);
	EXT4_INODE_GET_XTIME(i_mtime, inode, raw_inode);
	EXT4_INODE_GET_XTIME(i_atime, inode, raw_inode);
	EXT4_EINODE_GET_XTIME(i_crtime, ei, raw_inode);

	// todo: hurd?
	if (likely(!test_opt2(inode->i_sb, HURD_COMPAT))) {
		u64 ivers = le32_to_cpu(raw_inode->i_disk_version);

		if (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {
			if (EXT4_FITS_IN_INODE(raw_inode, ei, i_version_hi))
				ivers |=
		    (__u64)(le32_to_cpu(raw_inode->i_version_hi)) << 32;
		}
		ext4_inode_set_iversion_queried(inode, ivers);
	}

	ret = 0;

	// acl检查
	if (ei->i_file_acl &&
	    !ext4_inode_block_valid(inode, ei->i_file_acl, 1)) {
		ext4_error_inode(inode, function, line, 0,
				 "iget: bad extended attribute block %llu",
				 ei->i_file_acl);
		ret = -EFSCORRUPTED;
		goto bad_inode;
	
	// 检查inode的extent或者间接块的有效性?
	} else if (!ext4_has_inline_data(inode)) {
		/* validate the block references in the inode */
		if (!(EXT4_SB(sb)->s_mount_state & EXT4_FC_REPLAY) &&
			(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||
			(S_ISLNK(inode->i_mode) &&
			!ext4_inode_is_fast_symlink(inode)))) {
			if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))
				ret = ext4_ext_check_inode(inode);
			else
				ret = ext4_ind_check_inode(inode);
		}
	}
	// 上面的检查出错
	if (ret)
		goto bad_inode;

	// 根据文件类型设置不同函数表
	if (S_ISREG(inode->i_mode)) {
		// 普通文件

		// inode op
		inode->i_op = &ext4_file_inode_operations;
		// file op
		inode->i_fop = &ext4_file_operations;
		// mapping op
		ext4_set_aops(inode);
	} else if (S_ISDIR(inode->i_mode)) {
		// 目录
		inode->i_op = &ext4_dir_inode_operations;
		inode->i_fop = &ext4_dir_operations;
	} else if (S_ISLNK(inode->i_mode)) {
		// 链接文件

		// vfs不允许设置这两个属性给链接
		if (IS_APPEND(inode) || IS_IMMUTABLE(inode)) {
			ext4_error_inode(inode, function, line, 0,
					 "iget: immutable or append flags "
					 "not allowed on symlinks");
			ret = -EFSCORRUPTED;
			goto bad_inode;
		}
		if (IS_ENCRYPTED(inode)) {
			// 已加密
			inode->i_op = &ext4_encrypted_symlink_inode_operations;
			ext4_set_aops(inode);
		} else if (ext4_inode_is_fast_symlink(inode)) {
			// 快速软链接
			inode->i_link = (char *)ei->i_data;
			inode->i_op = &ext4_fast_symlink_inode_operations;
			nd_terminate_link(ei->i_data, inode->i_size,
				sizeof(ei->i_data) - 1);
		} else {
			// 普通软链接
			inode->i_op = &ext4_symlink_inode_operations;
			ext4_set_aops(inode);
		}
		// 设置mapping分配内存的标志为GFP_USER
		inode_nohighmem(inode);

	// 特殊文件
	} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||
	      S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {
		inode->i_op = &ext4_special_inode_operations;
		// 老文件系统用block[0]存设备号, 新的用block[1]
		if (raw_inode->i_block[0])
			init_special_inode(inode, inode->i_mode,
			   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));
		else
			init_special_inode(inode, inode->i_mode,
			   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));
	// boot_loader
	} else if (ino == EXT4_BOOT_LOADER_INO) {
		make_bad_inode(inode);
	} else {
		// 其他都是错的
		ret = -EFSCORRUPTED;
		ext4_error_inode(inode, function, line, 0,
				 "iget: bogus i_mode (%o)", inode->i_mode);
		goto bad_inode;
	}
	// 有casefolded标志, 却没这个特性
	if (IS_CASEFOLDED(inode) && !ext4_has_feature_casefold(inode->i_sb))
		ext4_error_inode(inode, function, line, 0,
				 "casefold flag without casefold feature");
	brelse(iloc.bh);

	unlock_new_inode(inode);
	return inode;

bad_inode:
	brelse(iloc.bh);
	iget_failed(inode);
	return ERR_PTR(ret);
}
```

```c
static int __ext4_get_inode_loc_noinmem(struct inode *inode,
					struct ext4_iloc *iloc)
{
	ext4_fsblk_t err_blk = 0;
	int ret;

	// 读出inode信息所在块, 或从内存里读取, 或从磁盘上读取
	ret = __ext4_get_inode_loc(inode->i_sb, inode->i_ino, iloc, 0,
					&err_blk);

	if (ret == -EIO)
		ext4_error_inode_block(inode, err_blk, EIO,
					"unable to read itable block");

	return ret;
}

static int __ext4_get_inode_loc(struct super_block *sb, unsigned long ino,
				struct ext4_iloc *iloc, int in_mem,
				ext4_fsblk_t *ret_block)
{
	struct ext4_group_desc	*gdp;
	struct buffer_head	*bh;
	ext4_fsblk_t		block;
	struct blk_plug		plug;
	int			inodes_per_block, inode_offset;

	iloc->bh = NULL;
	// 块号不规范
	if (ino < EXT4_ROOT_INO ||
	    ino > le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count))
		return -EFSCORRUPTED;

	// inode所在组号
	iloc->block_group = (ino - 1) / EXT4_INODES_PER_GROUP(sb);
	// 组描述符
	gdp = ext4_get_group_desc(sb, iloc->block_group, NULL);
	if (!gdp)
		return -EIO;

	// 每个块的inode数
	inodes_per_block = EXT4_SB(sb)->s_inodes_per_block;
	// inode组内偏移
	inode_offset = ((ino - 1) %
			EXT4_INODES_PER_GROUP(sb));
	// inode所在块
	block = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block);
	// inode在块里的偏移
	iloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb);

	// 读块
	bh = sb_getblk(sb, block);
	if (unlikely(!bh))
		return -ENOMEM;
	// 调试
	if (ext4_simulate_fail(sb, EXT4_SIM_INODE_EIO))
		goto simulate_eio;
	// bh不是更新的
	if (!buffer_uptodate(bh)) {
		lock_buffer(bh);

		// 加锁之后可能已经更新
		if (ext4_buffer_uptodate(bh)) {
			/* someone brought it uptodate while we waited */
			unlock_buffer(bh);
			goto has_buffer;
		}

		/*
		 * 如果我们所有的信息都在内存里，而且只对这个块有效，我们不需要读块
		 */
		if (in_mem) {
			struct buffer_head *bitmap_bh;
			int i, start;

			start = inode_offset & ~(inodes_per_block - 1);

			/* Is the inode bitmap in cache? */
			bitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp));
			if (unlikely(!bitmap_bh))
				goto make_io;

			/*
			 * If the inode bitmap isn't in cache then the
			 * optimisation may end up performing two reads instead
			 * of one, so skip it.
			 */
			if (!buffer_uptodate(bitmap_bh)) {
				brelse(bitmap_bh);
				goto make_io;
			}
			for (i = start; i < start + inodes_per_block; i++) {
				if (i == inode_offset)
					continue;
				if (ext4_test_bit(i, bitmap_bh->b_data))
					break;
			}
			brelse(bitmap_bh);
			if (i == start + inodes_per_block) {
				/* all other inodes are free, so skip I/O */
				memset(bh->b_data, 0, bh->b_size);
				set_buffer_uptodate(bh);
				unlock_buffer(bh);
				goto has_buffer;
			}
		}

make_io:
		/*
		 * 因为下面要读bh, 所以顺便把inode表读出来，就顺便预读一个inode-table.
		 */
		blk_start_plug(&plug);
		// 可以预读
		if (EXT4_SB(sb)->s_inode_readahead_blks) {
			ext4_fsblk_t b, end, table;
			unsigned num;
			// 预读数量
			__u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks;

			// inode表的起始块
			table = ext4_inode_table(sb, gdp);
			
			// 需要的inode块对齐到预读的起点
			b = block & ~((ext4_fsblk_t) ra_blks - 1);
			// 如果table大于起点, 则从table开始
			if (table > b)
				b = table;
			// 预读终点
			end = b + ra_blks;
			// 每组inode数
			num = EXT4_INODES_PER_GROUP(sb);
			// 有 组校验和时，要预留空间, 减去未使用的
			if (ext4_has_group_desc_csum(sb))
				num -= ext4_itable_unused_count(sb, gdp);
			// 算出inode表的末尾块, num是当前以使用的inode数量
			table += num / inodes_per_block;
			// 如果预读块数大于表结尾, 则只预读需要的
			if (end > table)
				end = table;
			// 读整个inode表
			while (b <= end)
				ext4_sb_breadahead_unmovable(sb, b++);
		}

		/*
		 * There are other valid inodes in the buffer, this inode
		 * has in-inode xattrs, or we don't have this inode in memory.
		 * Read the block from disk.
		 */
		trace_ext4_load_inode(sb, ino);
		// 读bh
		ext4_read_bh_nowait(bh, REQ_META | REQ_PRIO, NULL);
		blk_finish_plug(&plug);
		// 等bh读完
		wait_on_buffer(bh);

		// 等完之后, 如果bh不是最新的, 则出错
		if (!buffer_uptodate(bh)) {
		simulate_eio:
			if (ret_block)
				*ret_block = block;
			brelse(bh);
			return -EIO;
		}
	}
has_buffer:
	// 设置bh
	iloc->bh = bh;
	return 0;
}
```